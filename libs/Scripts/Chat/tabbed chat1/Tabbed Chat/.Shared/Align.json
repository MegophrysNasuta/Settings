{
    "attribs": {
        "isActive": "yes",
        "isFolder": "no"
    },
    "type": "script",
    "name": "Align",
    "packageName": null,
    "script": "\nfunction align(str,options) --str is a string, options is a table\n--[[ If they sent anything but a table as the second argument, return useful\ninfo. But if they didn't send a second argument then that's ok, the defaults\nwill be enough to get by and just center the txt\n]]--\n  if (type(options) ~= \"table\") and (options ~= nil) then return \"You call this with align(\\\"some text to format\\\", <table of options>. Pls check comments for what options and usage information\" end\n  options = options or {} --if they sent options, don't overwrite them\n  options.width = options.width or 80 --default line length of 80\n  options.alignment = options.alignment or \"center\" --if we don't specify, it's centered\n  options.cap = options.cap or \"\" --default endcap of nothing (an empty string, technically)\n  options.spacer = options.spacer or \" \" --default spacer is.. well.. space\n  options.inside = options.inside or false --by default, when centering, formation as spacers|cap|text|cap|spacers\n  if not options.mirror == false then options.mirror = options.mirror or true end--by default, we do want to use mirroring for the caps\n  local strLen = string.len(str)\n  local leftCap = options.cap\n  local rightCap = options.cap\n  local leftPadLen = math.floor((options.width - strLen)/2,1) - 1\n  local rightPadLen = leftPadLen + ((options.width - strLen)%2)\n  local maxPad = 0\n  local capLen = string.len(options.cap)\n  if capLen > leftPadLen then --if the cap is bigger than the left total padding\n    options.cap = options.cap:sub(1, leftPadLen) -- trim it up right!\n    capLen = string.len(options.cap)\n  end --otherwise, don't mess with it\n\n \n  if options.alignment == \"center\" then --we're going to center something\n    leftPadLen = math.floor((options.width - strLen)/2,1) - 1 --get the padding needed on the left\n    rightPadLen = leftPadLen + ((options.width - strLen)%2) --and on the right\n    if options.mirror then --if we're reversing the left cap and the right cap (IE {{[[ turns into ]]}} )\n      rightCap = string.gsub(rightCap, \"<\", \">\")\n      rightCap = string.gsub(rightCap, \"%[\", \"%]\")\n      rightCap = string.gsub(rightCap, \"{\", \"}\")\n      rightCap = string.gsub(rightCap, \"%(\", \"%)\")\n      rightCap = string.reverse(rightCap)\n    end --otherwise, they'll be the same, so don't do anything\n    str = string.format(\" %s \", str)\n   \n  elseif options.alignment == \"right\" then --we'll right-align the text\n    leftPadLen = options.width - strLen - 1\n    rightPadLen = 0\n    rightCap = \"\"\n    str = string.format(\" %s\", str)\n   \n  else --Ok, so if it's not center or right, we assume it's left. We don't do justified. Sorry.\n    leftPadLen = 0\n    rightPadLen = options.width - strLen -1\n    leftCap = \"\"\n    str = string.format(\"%s \", str)\n  end--that's it, took care of both left, right, and center formattings, now to output the durn thing.\n \n  if options.inside then\n  --if we're placing the repated spacer inside\n  --\"=====endcap some text endcap=====\"\n  --\"=====endcap some text pacdne=====\"\n  --\"=================endcap some text\"\n  --\"some text endcap=================\"\n    return leftCap .. string.rep(options.spacer, (leftPadLen - capLen)) .. str ..string.rep(options.spacer, (rightPadLen - capLen)).. rightCap\n  else\n  --otherwise, it''s be the spaces on the 'inside'\n  -- \"endcap===== some text =====endcap\"\n  -- \"endcap===== some text =====pacdne\"\n  -- \"endcap================= some text\"\n  -- \"some text =================endcap\"\n    return string.rep(options.spacer, (leftPadLen - capLen)) .. leftCap .. str .. rightCap .. string.rep(options.spacer, (rightPadLen - capLen))\n  end\nend\n\n\nfunction calign(str,options) --str is a string, options is a table\n--[[ If they sent anything but a table as the second argument, return useful \ninfo. But if they didn't send a second argument then that's ok, the defaults \nwill be enough to get by and just center the txt\n]]--\n  if (not type(options) == \"table\") and (not options == nil) then return \"You call this with align(\\\"some text to format\\\", <table of options>. Pls check comments for what options and usage information\" end \n  options = options or {} --if they sent options, don't overwrite them\n  options.width = options.width or 80 --default line length of 80\n  options.alignment = options.alignment or \"center\" --if we don't specify, it's centered\n  options.cap = options.cap or \"\" --default endcap of nothing (an empty string, technically)\n  options.spacer = options.spacer or \" \" --default spacer is.. well.. space\n  options.inside = options.inside or false --by default, when centering, formation as spacers|cap|text|cap|spacers\n  options.capColor = options.capColor or \"<white>\"--by default, don't change the color of the caps\n  options.spacerColor = options.spacerColor or \"<white>\"\n  options.textColor = options.textColor or \"<white>\"--or the text\n  if not options.mirror == false then options.mirror = options.mirror or true end--by default, we do want to use mirroring for the caps\n  local strLen = string.len(str)\n  local leftCap = options.cap\n  local rightCap = options.cap\n  local leftPadLen = math.floor((options.width - strLen)/2,1) - 1\n  local rightPadLen = leftPadLen + ((options.width - strLen)%2)\n  local maxPad = 0\n  local capLen = string.len(options.cap)\n  if capLen > leftPadLen then --if the cap is bigger than the left total padding\n    options.cap = options.cap:sub(1, leftPadLen) -- trim it up right!\n    capLen = string.len(options.cap)\n  end --otherwise, don't mess with it\n\n  \n  if options.alignment == \"center\" then --we're going to center something\n    leftPadLen = math.floor((options.width - strLen)/2,1) - 1 --get the padding needed on the left\n    rightPadLen = leftPadLen + ((options.width - strLen)%2) --and on the right\n    if options.mirror then --if we're reversing the left cap and the right cap (IE {{[[ turns into ]]}} )\n      rightCap = string.gsub(rightCap, \"<\", \">\")\n      rightCap = string.gsub(rightCap, \"%[\", \"%]\")\n      rightCap = string.gsub(rightCap, \"{\", \"}\")\n      rightCap = string.gsub(rightCap, \"%(\", \"%)\")\n      rightCap = string.reverse(rightCap)\n    end --otherwise, they'll be the same, so don't do anything\n    str = string.format(\" %s \", str)\n    \n  elseif options.alignment == \"right\" then --we'll right-align the text\n    leftPadLen = options.width - strLen - 1\n    rightPadLen = 0\n    rightCap = \"\"\n    str = string.format(\" %s\", str)\n    \n  else --Ok, so if it's not center or right, we assume it's left. We don't do justified. Sorry.\n    leftPadLen = 0\n    rightPadLen = options.width - strLen -1\n    leftCap = \"\"\n    str = string.format(\"%s \", str)\n  end--that's it, took care of both left, right, and center formattings, now to output the durn thing. \n  \n  if options.inside then \n  --if we're placing the repated spacer inside\n  --\"=====endcap some text endcap=====\" \n  --\"=====endcap some text pacdne=====\"\n  --\"=================endcap some text\" \n  --\"some text endcap=================\"\n    return options.capColor .. leftCap .. options.spacerColor.. string.rep(options.spacer, (leftPadLen - capLen)) .. options.textColor .. str .. options.spacerColor ..string.rep(options.spacer, (rightPadLen - capLen)) .. options.capColor .. rightCap\n  else \n  --otherwise, it''s be the spaces on the 'inside'\n  -- \"endcap===== some text =====endcap\"\n  -- \"endcap===== some text =====pacdne\" \n  -- \"endcap================= some text\" \n  -- \"some text =================endcap\"\n    return options.spacerColor .. string.rep(options.spacer, (leftPadLen - capLen)) .. options.capColor .. leftCap .. options.textColor .. str .. options.capColor .. rightCap .. options.spacerColor .. string.rep(options.spacer, (rightPadLen - capLen))\n  end\nend\n\nfunction dalign(str,options) --str is a string, options is a table\n--[[ If they sent anything but a table as the second argument, return useful \ninfo. But if they didn't send a second argument then that's ok, the defaults \nwill be enough to get by and just center the txt\n]]--\n  if (not type(options) == \"table\") and (not options == nil) then return \"You call this with align(\\\"some text to format\\\", <table of options>. Pls check comments for what options and usage information\" end \n  options = options or {} --if they sent options, don't overwrite them\n  options.width = options.width or 80 --default line length of 80\n  options.alignment = options.alignment or \"center\" --if we don't specify, it's centered\n  options.cap = options.cap or \"\" --default endcap of nothing (an empty string, technically)\n  options.spacer = options.spacer or \" \" --default spacer is.. well.. space\n  options.inside = options.inside or false --by default, when centering, formation as spacers|cap|text|cap|spacers\n  options.capColor = options.capColor or \"<255,255,255>\"--by default, don't change the color of the caps\n  options.spacerColor = options.spacerColor or \"<255,255,255>\" \n  options.textColor = options.textColor or \"<255,255,255>\"--or the text\n  if not options.mirror == false then options.mirror = options.mirror or true end--by default, we do want to use mirroring for the caps\n  local strLen = string.len(str)\n  local leftCap = options.cap\n  local rightCap = options.cap\n  local leftPadLen = math.floor((options.width - strLen)/2,1) - 1\n  local rightPadLen = leftPadLen + ((options.width - strLen)%2)\n  local maxPad = 0\n  local capLen = string.len(options.cap)\n  if capLen > leftPadLen then --if the cap is bigger than the left total padding\n    options.cap = options.cap:sub(1, leftPadLen) -- trim it up right!\n    capLen = string.len(options.cap)\n  end --otherwise, don't mess with it\n\n  \n  if options.alignment == \"center\" then --we're going to center something\n    leftPadLen = math.floor((options.width - strLen)/2,1) - 1 --get the padding needed on the left\n    rightPadLen = leftPadLen + ((options.width - strLen)%2) --and on the right\n    if options.mirror then --if we're reversing the left cap and the right cap (IE {{[[ turns into ]]}} )\n      rightCap = string.gsub(rightCap, \"<\", \">\")\n      rightCap = string.gsub(rightCap, \"%[\", \"%]\")\n      rightCap = string.gsub(rightCap, \"{\", \"}\")\n      rightCap = string.gsub(rightCap, \"%(\", \"%)\")\n      rightCap = string.reverse(rightCap)\n    end --otherwise, they'll be the same, so don't do anything\n    str = string.format(\" %s \", str)\n    \n  elseif options.alignment == \"right\" then --we'll right-align the text\n    leftPadLen = options.width - strLen - 1\n    rightPadLen = 0\n    rightCap = \"\"\n    str = string.format(\" %s\", str)\n    \n  else --Ok, so if it's not center or right, we assume it's left. We don't do justified. Sorry.\n    leftPadLen = 0\n    rightPadLen = options.width - strLen -1\n    leftCap = \"\"\n    str = string.format(\"%s \", str)\n  end--that's it, took care of both left, right, and center formattings, now to output the durn thing. \n  \n  if options.inside then \n  --if we're placing the repated spacer inside\n  --\"=====endcap some text endcap=====\" \n  --\"=====endcap some text pacdne=====\"\n  --\"=================endcap some text\" \n  --\"some text endcap=================\"\n    return options.capColor .. leftCap .. options.spacerColor.. string.rep(options.spacer, (leftPadLen - capLen)) .. options.textColor .. str .. options.spacerColor ..string.rep(options.spacer, (rightPadLen - capLen)) .. options.capColor .. rightCap\n  else \n  --otherwise, it''s be the spaces on the 'inside'\n  -- \"endcap===== some text =====endcap\"\n  -- \"endcap===== some text =====pacdne\" \n  -- \"endcap================= some text\" \n  -- \"some text =================endcap\"\n    return options.spacerColor .. string.rep(options.spacer, (leftPadLen - capLen)) .. options.capColor .. leftCap .. options.textColor .. str .. options.capColor .. rightCap .. options.spacerColor .. string.rep(options.spacer, (rightPadLen - capLen))\n  end\nend\n\nfunction halign(str,options) --str is a string, options is a table\n--[[ If they sent anything but a table as the second argument, return useful \ninfo. But if they didn't send a second argument then that's ok, the defaults \nwill be enough to get by and just center the txt\n]]--\n  if (not type(options) == \"table\") and (not options == nil) then return \"You call this with align(\\\"some text to format\\\", <table of options>. Pls check comments for what options and usage information\" end \n  options = options or {} --if they sent options, don't overwrite them\n  options.width = options.width or 80 --default line length of 80\n  options.alignment = options.alignment or \"center\" --if we don't specify, it's centered\n  options.cap = options.cap or \"\" --default endcap of nothing (an empty string, technically)\n  options.spacer = options.spacer or \" \" --default spacer is.. well.. space\n  options.inside = options.inside or false --by default, when centering, formation as spacers|cap|text|cap|spacers\n  options.capColor = options.capColor or \"|cFFFFFF\"--by default, don't change the color of the caps\n  options.spacerColor = options.spacerColor or \"|cFFFFFF\" \n  options.textColor = options.textColor or \"|cFFFFFF\"--or the text\n  if not options.mirror == false then options.mirror = options.mirror or true end--by default, we do want to use mirroring for the caps\n  local strLen = string.len(str)\n  local leftCap = options.cap\n  local rightCap = options.cap\n  local leftPadLen = math.floor((options.width - strLen)/2,1) - 1\n  local rightPadLen = leftPadLen + ((options.width - strLen)%2)\n  local maxPad = 0\n  local capLen = string.len(options.cap)\n  if capLen > leftPadLen then --if the cap is bigger than the left total padding\n    options.cap = options.cap:sub(1, leftPadLen) -- trim it up right!\n    capLen = string.len(options.cap)\n  end --otherwise, don't mess with it\n\n  \n  if options.alignment == \"center\" then --we're going to center something\n    leftPadLen = math.floor((options.width - strLen)/2,1) - 1 --get the padding needed on the left\n    rightPadLen = leftPadLen + ((options.width - strLen)%2) --and on the right\n    if options.mirror then --if we're reversing the left cap and the right cap (IE {{[[ turns into ]]}} )\n      rightCap = string.gsub(rightCap, \"<\", \">\")\n      rightCap = string.gsub(rightCap, \"%[\", \"%]\")\n      rightCap = string.gsub(rightCap, \"{\", \"}\")\n      rightCap = string.gsub(rightCap, \"%(\", \"%)\")\n      rightCap = string.reverse(rightCap)\n    end --otherwise, they'll be the same, so don't do anything\n    str = string.format(\" %s \", str)\n    \n  elseif options.alignment == \"right\" then --we'll right-align the text\n    leftPadLen = options.width - strLen - 1\n    rightPadLen = 0\n    rightCap = \"\"\n    str = string.format(\" %s\", str)\n    \n  else --Ok, so if it's not center or right, we assume it's left. We don't do justified. Sorry.\n    leftPadLen = 0\n    rightPadLen = options.width - strLen -1\n    leftCap = \"\"\n    str = string.format(\"%s \", str)\n  end--that's it, took care of both left, right, and center formattings, now to output the durn thing. \n  \n  if options.inside then \n  --if we're placing the repated spacer inside\n  --\"=====endcap some text endcap=====\" \n  --\"=====endcap some text pacdne=====\"\n  --\"=================endcap some text\" \n  --\"some text endcap=================\"\n    return options.capColor .. leftCap .. options.spacerColor.. string.rep(options.spacer, (leftPadLen - capLen)) .. options.textColor .. str .. options.spacerColor ..string.rep(options.spacer, (rightPadLen - capLen)) .. options.capColor .. rightCap\n  else \n  --otherwise, it''s be the spaces on the 'inside'\n  -- \"endcap===== some text =====endcap\"\n  -- \"endcap===== some text =====pacdne\" \n  -- \"endcap================= some text\" \n  -- \"some text =================endcap\"\n    return options.spacerColor .. string.rep(options.spacer, (leftPadLen - capLen)) .. options.capColor .. leftCap .. options.textColor .. str .. options.capColor .. rightCap .. options.spacerColor .. string.rep(options.spacer, (rightPadLen - capLen))\n  end\nend\n ",
    "eventHandlerList": null
}