{
    "attribs": {
        "isActive": "yes",
        "isFolder": "no"
    },
    "type": "script",
    "name": "speedwalking",
    "packageName": null,
    "script": "function mmp.gotoRoom(where, dashtype, gotoType)\n  mmp.speedWalk.type = gotoType or \"room\"\n  if not where or not tonumber(where) then\n    mmp.echo(\"Where do you want to go to?\")\n    return\n  end\n  if tonumber(where) == mmp.currentroom then\n    mmp.echo(\"We're already at \" .. where .. \"!\")\n    raiseEvent(\"mmapper arrived\")\n    return\n  end\n  -- allow mapper 'addons' to link their own exits in\n  raiseEvent(\"mmp link externals\")\n  -- if getPath worked, then the dirs and room #'s tables were populated for us\n  if not mmp.getPath(mmp.currentroom, tonumber(where)) then\n    mmp.echo(\"Don't know how to get there (\" .. tostring(where) .. \") from here :(\")\n    mmp.speedWalkPath = {}\n    mmp.speedWalkDir = {}\n    speedWalkCounter = 0\n    raiseEvent(\"mmapper failed path\")\n    if mmp.settings.shackle then\n      expandAlias(\"wear shackle\")\n    end\n    -- allow mapper 'addons' to unlink their special exits\n    raiseEvent(\"mmp clear externals\")\n    return\n  end\n  doSpeedWalk(dashtype)\n  -- allow mapper 'addons' to unlink their special exits\n  raiseEvent(\"mmp clear externals\")\nend\n\nfunction mmp.gotoArea(where, number, dashtype, exact)\n  mmp.speedWalk.type = \"area\"\n  if not where or type(where) ~= \"string\" then\n    mmp.echo(\"Where do you want to go to?\")\n    return\n  end\n  local where = where:lower()\n  number = tonumber(number)\n  local tmp = getRoomUserData(1, \"gotoMapping\")\n  if not tmp or tmp == '' then\n    tmp = \"[]\"\n  end\n  local temp, maptable = yajl.to_value(tmp), {}\n  for k, v in pairs(temp) do\n    maptable[k:lower()] = v\n  end\n  local destinationRoom = maptable[where]\n  if destinationRoom then\n    mmp.gotoRoom(destinationRoom, dashtype)\n    return\n  end\n  local areaid, msg, multiples = mmp.findAreaID(where, exact)\n  if areaid then\n    mmp.gotoAreaID(areaid)\n  elseif not areaid and #multiples > 0 then\n    if number and number <= #multiples then\n      mmp.gotoArea(multiples[number], nil, dashtype, true)\n      return\n    end\n    mmp.echo(\"Which area would you like to go to?\")\n    fg(\"DimGrey\")\n    for key, areaname in ipairs(multiples) do\n      echo(\"  \")\n      echoLink(\n        key .. \") \",\n        'mmp.gotoArea(\"' ..\n        areaname ..\n        '\", nil, ' ..\n        (dashtype and '\"' .. dashtype .. '\"' or \"nil\") ..\n        ', true)',\n        \"Click to go to \" .. areaname,\n        true\n      )\n      setUnderline(true)\n      echoLink(\n        areaname,\n        'mmp.gotoArea(\"' ..\n        areaname ..\n        '\", nil, ' ..\n        (dashtype and '\"' .. dashtype .. '\"' or \"nil\") ..\n        ', true)',\n        \"Click to go to \" .. areaname,\n        true\n      )\n      setUnderline(false)\n      echo(\"\\n\")\n    end\n    resetFormat()\n    return\n  else\n    mmp.echo(string.format(\"Don't know of any area named '%s'.\", where))\n    return\n  end\nend\n\n--- DOES NOT ACCOUNT FOR CHANGING THE MAP YET (within a profile load), because we don't know when it happens\nlocal getpathcache = {}\n--setmetatable(getpathcache, {__mode = \"kv\"}) -- weak keys/values = it'll periodically get cleaned up by gc\n\nfunction mmp.getPath(from, to)\n  assert(tonumber(from) and tonumber(to), \"mmp.getPath: both from and to have to be room IDs\")\n  local key = string.format(\"%s_%s\", from, to)\n  local resulttbl = getpathcache[key]\n  -- not in cache?\n  if not resulttbl then\n    mmp.computeGetPath = mmp.computeGetPath or createStopWatch()\n    startStopWatch(mmp.computeGetPath)\n    local boolean = getPath(from, to)\n    if mmp.debug then\n      mmp.echo(\n        \"a new getPath() from \" ..\n        from ..\n        \" to \" ..\n        to ..\n        \" took \" ..\n        stopStopWatch(mmp.computeGetPath) ..\n        \"s.\"\n      )\n    end\n    -- save it into the cache & send away\n    getpathcache[key] = {boolean, speedWalkDir, speedWalkPath}\n    return boolean\n  end\n  -- or if it is, retrieve & send away\n  speedWalkDir = resulttbl[2]\n  speedWalkPath = resulttbl[3]\n  return resulttbl[1]\nend\n\nfunction mmp.clearpathcache()\n  if mmp.debug then\n    mmp.echo(\"path cache cleared\")\n  end\n  getpathcache = {}\nend\n\nregisterAnonymousEventHandler(\"mmapper updated map\",\"mmp.clearpathcache\")\n\nfunction mmp.showpathcache()\n  return getpathcache\nend\n\nfunction mmp.setmovetimer(time)\n  if mmp.movetimer then\n    killTimer(mmp.movetimer)\n  end\n  if mmp.settings.slowwalk and not mmp.hasty then\n    return\n  end\n  local laglevel = mmp.settings.laglevel or 1\n  time = time or mmp.lagtable[laglevel].time\n  mmp.movetimer =\n    tempTimer(\n      getNetworkLatency() + time,\n      function()\n        mmp.movetimer = false\n        mmp.move()\n      end\n    )\nend\n\n-- moves to the next room we need to.\n\nfunction mmp.move()\n  if mmp.paused or not mmp.autowalking or mmp.movetimer or not mmp.canmove() then\n    return\n  end\n  -- sometimes it's 0 - default to 1\n  if speedWalkCounter == 0 then\n    speedWalkCounter = 1\n  end\n  local cmd\n  if mmp.settings[\"caravan\"] then\n    cmd = \"lead caravan \" .. mmp.speedWalkDir[speedWalkCounter]\n  else\n    cmd = mmp.speedWalkDir[speedWalkCounter]\n  end\n  cmd = cmd or ''\n  -- timeout before loadstring, so it can set its own if it would like to.\n  mmp.setmovetimer()\n  if string.starts(cmd, \"script:\") then\n    cmd = string.gsub(cmd, \"script:\", \"\")\n    loadstring(cmd)()\n    if mmp.settings.showcmds and not mmp.hasty then\n      cecho(\n        string.format(\n          \"<red>(<maroon>%d - <dark_slate_grey>%s<red>)\",\n          #mmp.speedWalkDir - speedWalkCounter + 1,\n          \"<script>\"\n        )\n      )\n    end\n    mmp.hasty = false\n  else\n    send(cmd, false)\n    if mmp.settings.showcmds and not mmp.hasty then\n      cecho(\n        string.format(\n          \"<red>(<maroon>%d - <dark_slate_grey>%s<red>)\",\n          #mmp.speedWalkDir - speedWalkCounter + 1,\n          cmd\n        )\n      )\n    end\n    mmp.hasty = false\n  end\nend\n\nfunction mmp.swim()\n  -- not going anywhere? don't do anything\n  if not mmp.speedWalkDir[speedWalkCounter] then\n    return\n  end\n  send(\n    \"swim \" ..\n    mmp.speedWalkDir[speedWalkCounter]:gsub(\"sprint \", \"\"):gsub(\"dash \", \"\"):gsub(\"gallop \", \"\"):gsub(\n      \"runaway \", \"\"\n    ),\n    false\n  )\n  if mmp.settings.showcmds then\n    cecho(\n      string.format(\n        \"<red>(<maroon>%d - <dark_slate_grey>swim %s<red>)\",\n        #mmp.speedWalkDir - speedWalkCounter + 1,\n        mmp.speedWalkDir[speedWalkCounter]:gsub(\"sprint \", \"\"):gsub(\"dash \", \"\"):gsub(\"gallop \", \"\"):gsub(\n          \"runaway \", \"\"\n        )\n      )\n    )\n  end\n  mmp.hasty = true\n  mmp.setmovetimer(2.5)\nend\n\nfunction mmp.enterGrate()\n  -- not going anywhere? don't do anything\n  if not mmp.speedWalkDir[speedWalkCounter] then\n    return\n  end\n  send(\"enter grate \" .. mmp.speedWalkDir[speedWalkCounter], false)\n  if mmp.settings.showcmds then\n    cecho(\n      string.format(\n        \"<red>(<maroon>%d - <dark_slate_grey>enter grate %s<red>)\",\n        #mmp.speedWalkDir - speedWalkCounter + 1,\n        mmp.speedWalkDir[speedWalkCounter]\n      )\n    )\n  end\n  mmp.hasty = true\n  mmp.setmovetimer(2.5)\nend\n\nfunction mmp.openDoor()\n  -- not going anywhere? don't do anything\n  if not mmp.speedWalkDir[speedWalkCounter] then\n    return\n  end\n  if mmp.game == \"asteria\" then\n   send(\n    \"open \" ..\n    mmp.speedWalkDir[speedWalkCounter]:gsub(\"sprint \", \"\"):gsub(\"dash \", \"\"):gsub(\"gallop \", \"\"):gsub(\n      \"runaway \", \"\"\n    ),\n    false\n  )\n  if mmp.settings.showcmds then\n    cecho(\n      string.format(\n        \"<red>(<maroon>%d - <dark_slate_grey>open %s<red>)\",\n        #mmp.speedWalkDir - speedWalkCounter + 1,\n        mmp.speedWalkDir[speedWalkCounter]:gsub(\"sprint \", \"\"):gsub(\"dash \", \"\"):gsub(\"gallop \", \"\"):gsub(\n          \"runaway \", \"\"\n        )\n      )\n    )\n  end\nelse\n  send(\n    \"open door \" ..\n    mmp.speedWalkDir[speedWalkCounter]:gsub(\"sprint \", \"\"):gsub(\"dash \", \"\"):gsub(\"gallop \", \"\"):gsub(\n      \"runaway \", \"\"\n    ),\n    false\n  )\n  if mmp.settings.showcmds then\n    cecho(\n      string.format(\n        \"<red>(<maroon>%d - <dark_slate_grey>open door %s<red>)\",\n        #mmp.speedWalkDir - speedWalkCounter + 1,\n        mmp.speedWalkDir[speedWalkCounter]:gsub(\"sprint \", \"\"):gsub(\"dash \", \"\"):gsub(\"gallop \", \"\"):gsub(\n          \"runaway \", \"\"\n        )\n      )\n    )\n  end\nend\n  mmp.hasty = true\n  mmp.setmovetimer(getNetworkLatency())\nend\n\nfunction mmp.unlockDoor()\n  -- not going anywhere? don't do anything\n  if not mmp.speedWalkDir[speedWalkCounter] then\n    return\n  end\n  send(\n    \"unlock door \" ..\n    mmp.speedWalkDir[speedWalkCounter]:gsub(\"sprint \", \"\"):gsub(\"dash \", \"\"):gsub(\"gallop \", \"\"):gsub(\n      \"runaway \", \"\"\n    ),\n    false\n  )\n  if mmp.settings.showcmds then\n    cecho(\n      string.format(\n        \"<red>(<maroon>%d - <dark_slate_grey>unlock door %s<red>)\",\n        #mmp.speedWalkDir - speedWalkCounter,\n        mmp.speedWalkDir[speedWalkCounter]:gsub(\"sprint \", \"\"):gsub(\"dash \", \"\"):gsub(\"gallop \", \"\"):gsub(\n          \"runaway \", \"\"\n        )\n      )\n    )\n  end\n  mmp.hasty = true\n  mmp.setmovetimer(getNetworkLatency())\nend\n\nfunction mmp.customwalkdelay(delay)\n  mmp.setmovetimer(getNetworkLatency() + delay)\nend\n\nfunction mmp.stop()\n  mmp.speedWalkPath = {}\n  mmp.speedWalkDir = {}\n  speedWalkCounter = 0\n  stopStopWatch(speedWalkWatch)\n  --if mmp.movetimer then killTimer( mmp.movetimer ) end\n  mmp.autowalking = false\n  -- clear all the temps we've got\n  for trigger, ID in pairs(mmp.specials) do\n    killTrigger(ID)\n  end\n  mmp.specials = {}\n  mmp.echo(\"Stopped walking.\")\n  raiseEvent(\"mmapper stopped\")\n  if mmp.settings.shackle then\n    expandAlias(\"wear shackle\")\n  end\nend\n\n-- Aetolia and Lusternia support showing balances in GMCP. This is easy to support, so we do!\n-- if we can't move, setup a polling timer to prompt walking when we can again.\n-- popular systems that expose balance & equilibrium values can be added here as well, perhaps though a similarly-named function.\n\nfunction mmp.canmove(fromtimer)\n  if mapper_can_move and mapper_can_move() then\n    if fromtimer then\n      mmp.move()\n    else\n      return true\n    end\n  elseif mapper_can_move then\n    tempTimer(0.2, [[mmp.canmove(true)]])\n    return false\n  end\n  if not gmcp.Char then\n    return true\n  end\n  -- Achaea\n  -- Lusternia\n if\n    (\n      gmcp.Char and\n      (not gmcp.Char.Vitals.bal or gmcp.Char.Vitals.bal == \"1\") and\n      (not gmcp.Char.Vitals.eq or gmcp.Char.Vitals.eq == \"1\") and\n      (not gmcp.Char.Vitals.balance or gmcp.Char.Vitals.balance == \"1\") and\n      (not gmcp.Char.Vitals.equilibrium or gmcp.Char.Vitals.equilibrium == \"1\") and\n      (not gmcp.Char.Vitals.right_arm or gmcp.Char.Vitals.right_arm == \"1\") and\n      (not gmcp.Char.Vitals.left_arm or gmcp.Char.Vitals.left_arm == \"1\") and\n      (not gmcp.Char.Vitals.right_leg or gmcp.Char.Vitals.right_leg == \"1\") and\n      (not gmcp.Char.Vitals.left_leg or gmcp.Char.Vitals.left_leg == \"1\") and\n      (not gmcp.Char.Vitals.psisuper or gmcp.Char.Vitals.psisuper ~= \"0\") and\n      (not gmcp.Char.Vitals.psisub or gmcp.Char.Vitals.psisub ~= \"0\") and\n      (not gmcp.Char.Vitals.psiid or gmcp.Char.Vitals.psiid ~= \"0\") and\n      (not gmcp.Char.Balance or gmcp.Char.Balance.List.balance == \"1\") and\n      (not gmcp.Char.Balance or gmcp.Char.Balance.List.equilibrium == \"1\") and\n      (not gmcp.Char.Balance or gmcp.Char.Balance.List.rarm == \"1\") and\n      (not gmcp.Char.Balance or gmcp.Char.Balance.List.larm == \"1\") and\n      (not gmcp.Char.Balance or gmcp.Char.Balance.List.legs == \"1\") and\n      (not gmcp.Char.Vitals.prone or (gmcp.Char.Vitals.prone == \"0\" or gmcp.Char.Vitals.prone == 0)\n    ))\n  then\n    if fromtimer then\n      mmp.move()\n    else\n      return true\n    end\n  else\n    tempTimer(0.2, [[mmp.canmove(true)]])\n    return false\n  end\nend\n\nlocal oldnum\n\nfunction speedwalking(event, num)\n  local num = tonumber(num) or tonumber(gmcp.Room.Info.num)\n  if num ~= mmp.currentroom then\n    mmp.previousroom = mmp.currentroom\n  end\n  mmp.currentroom = num\n  mmp.currentroomname = getRoomName(num)\n  -- Try to track if we're flying or not, for Imperian wings\n  -- This is to avoid being \"off path\" if we FLY due to wings.\n  local madeflight = false\n  if gmcp.Room then\n    local flying = false\n    if string.find(gmcp.Room.Info.name, \"^flying above\") then\n      flying = true\n    end\n    if mmp.flying and not flying then\n      -- We were flying, and now we are not. Gravity!\n      mmp.flying = false\n    elseif not mmp.flying and flying then\n      -- We were not flying and now we are.\n      madeflight = true\n      mmp.flying = true\n    elseif not flying then\n      mmp.flying = false\n    end\n  else\n    mmp.flying = false\n  end\n  -- track if we're inside or outside, if possible\n  if gmcp.Room then\n    local areaID = getRoomArea(mmp.currentroom)\n    if\n      mmp.inside and\n      not (\n        table.contains(gmcp.Room.Info.details, \"indoors\") or\n        table.contains(gmcp.Room.Info.details, \"considered indoors\")\n      ) and\n      not mmp.orbed()\n    then\n      mmp.inside = false\n      raiseEvent(\"mmapper went outside\")\n    elseif\n      not mmp.inside and\n      (\n        table.contains(gmcp.Room.Info.details, \"indoors\") or\n        table.contains(gmcp.Room.Info.details, \"considered indoors\") or\n        mmp.orbed()\n      )\n    then\n      mmp.inside = true\n      raiseEvent(\"mmapper went inside\")\n    end\n    if\n      #table.n_union(\n        mmp.getareacontinents(getRoomArea(mmp.previousroom)),\n        mmp.getareacontinents(getRoomArea(num))\n      ) ~= #mmp.getareacontinents(getRoomArea(num))\n    then\n      raiseEvent(\"mmapper changed continent\")\n    end\n    -- the event could cancel speedwalking - in this case quit\n    if mmp.ignore_speedwalking then\n      mmp.ignore_speedwalking = nil\n      return\n    end\n  end\n  if oldnum == num then\n    return\n  else\n    oldnum = num\n  end\n  if not mmp.autowalking then\n    return\n  end\n  if mmp.movetimer then\n    killTimer(mmp.movetimer)\n    mmp.movetimer = false\n  end\n  if num == mmp.speedWalkPath[#mmp.speedWalkPath] then\n    local walktime = stopStopWatch(speedWalkWatch)\n    mmp.echo(string.format(\"We've arrived! Took us %.1fs.\\n\", walktime))\n    raiseEvent(\"mmapper arrived\")\n    if mmp.settings.shackle then\n      expandAlias(\"wear shackle\")\n    end\n    mmp.speedWalkPath = {}\n    mmp.speedWalkDir = {}\n    speedWalkCounter = 0\n    mmp.autowalking = false\n  elseif mmp.speedWalkPath[speedWalkCounter] == num then\n    speedWalkCounter = speedWalkCounter + 1\n    tempPromptTrigger(mmp.move, 1)\n  elseif mmp.game == \"imperian\" and madeflight then\n    mmp.echo(\"We began flying!\")\n    tempPromptTrigger(mmp.move, 1)\n  elseif\n    #mmp.speedWalkPath > 0 and\n    not mmp.ferry_rooms[num] and\n    not (gmcp.Room.Info.details and table.contains(gmcp.Room.Info.details, \"ferry\"))\n  then\n    -- ended up somewhere we didn't want to be, and this isn't a ferry room?\n    speedWalkMoved = false\n    -- re-calculate path then\n    mmp.echo(\"Ended up off the path, recalculating a new path...\")\n    local destination = mmp.speedWalkPath[#mmp.speedWalkPath]\n    if not mmp.getPath(num, destination) then\n      mmp.echo(\n        string.format(\n          \"Don't know how to get to %d (%s) anymore :( Move into a room we know of to continue\",\n          destination,\n          getRoomName(destination)\n        )\n      )\n    else\n      mmp.gotoRoom(destination)\n    end\n  end\nend\n\nfunction doSpeedWalk(dashtype)\n  mmp.speedWalkDir = mmp.deepcopy(speedWalkDir)\n  mmp.speedWalkPath = mmp.deepcopy(speedWalkPath)\n  speedWalkDir, speedWalkPath = {}, {}\n  resetStopWatch(speedWalkWatch)\n  startStopWatch(speedWalkWatch)\n  if\n    mmp.settings[\"gallop\"] or\n    mmp.settings[\"dash\"] or\n    mmp.settings.sprint or\n    mmp.settings.runaway or\n    dashtype\n  then\n    mmp.fixPath(\n      mmp.currentroom,\n      mmp.speedWalkPath[#mmp.speedWalkPath],\n      (mmp.settings[\"gallop\"] and \"gallop\") or\n      (mmp.settings[\"dash\"] and \"dash\") or\n      (mmp.settings.sprint and \"sprint\") or\n      (mmp.settings.runaway and \"runaway\") or\n      dashtype\n    )\n  end\n  mmp.fixSpecialExits(mmp.speedWalkDir)\n  if #mmp.speedWalkPath == 0 then\n    mmp.autowalking = false\n    mmp.echo(\"Couldn't find a path to the destination :(\")\n    raiseEvent(\"mmapper failed path\")\n    if mmp.settings.shackle then\n      expandAlias(\"wear shackle\")\n    end\n    return\n  end\n  -- this is a fix: convert nums to actual numbers\n  for i = 1, #mmp.speedWalkPath do\n    mmp.speedWalkPath[i] = tonumber(mmp.speedWalkPath[i])\n  end\n  mmp.autowalking = true\n  raiseEvent(\"s\")\n  if mmp.settings.shackle then\n    expandAlias(\"remove shackle\")\n  end\n  if not mmp.paused then\n    mmp.echon(\"Starting speedwalk from \" .. (atcp.RoomNum or gmcp.Room.Info.num) .. \" to \")\n    cechoLink(\n      \"<\" .. mmp.settings.echocolour .. \">\" .. mmp.speedWalkPath[#mmp.speedWalkPath],\n      'mmp.gotoRoom \"' .. mmp.speedWalkPath[#mmp.speedWalkPath] .. '\"',\n      'Go to ' .. mmp.speedWalkPath[#mmp.speedWalkPath],\n      true\n    )\n    echo(\": \")\n    speedWalkCounter = 1\n    if mmp.canmove() then\n      mmp.hasty = true\n      mmp.setmovetimer(0.1)\n    else\n      echo(\"(when we get balance back / aren't hindered)\")\n    end\n  else\n    mmp.echo(\n      \"Will go to \" ..\n      mmp.speedWalkPath[#mmp.speedWalkPath] ..\n      \" as soon as the mapper is unpaused.\"\n    )\n  end\nend\n\nfunction mmp.failpath()\n  if mmp.movetimer then\n    local walktime = stopStopWatch(speedWalkWatch)\n    mmp.echo(string.format(\"Can't continue further! Took us %.1fs to get here.\\n\", walktime))\n  end\n  mmp.autowalking = false\n  if mmp.settings.shackle then\n    expandAlias(\"wear shackle\")\n  end\n  mmp.speedWalkPath = {}\n  mmp.speedWalkDir = {}\n  speedWalkCounter = 0\n  if mmp.movetimer then\n    killTimer(mmp.movetimer)\n    mmp.movetimer = nil\n  end\n  raiseEvent(\"mmapper failed path\")\nend\n\nfunction mmp.changeBoolFunc(name, option)\n  local en\n  en = option and \"will now use\" or \"will no longer use\"\n  mmp.echo(\"<green>Okay, the mapper \" .. en .. \" <white>\" .. name .. \"<green>!\")\nend\n\nfunction mmp.fixPath(rFrom, rTo, dashtype)\n  local currentPath, currentIds = {}, {}\n  local dRef = {[\"n\"] = \"north\", [\"e\"] = \"east\", [\"s\"] = \"south\", [\"w\"] = \"west\"}\n  if not getPath(rFrom, rTo) then\n    return false\n  end\n  -- Logic: Look for a direction repeated at least two times.\n  -- count the number of times it repeats, then look that many rooms ahead.\n  -- if that room also contains the direction we're headed, just travel that many directions.\n  -- otherwise, dash.\n  local repCount = 1\n  local index = 1\n  local dashExaust = false\n  while mmp.speedWalkDir[index] do\n    if not table.contains(getSpecialExits(mmp.speedWalkPath[index]), mmp.speedWalkDir[index]) then\n      dashExaust = false\n      repCount = 1\n      while mmp.speedWalkDir[index + repCount] == mmp.speedWalkDir[index] do\n        repCount = repCount + 1\n        if repCount == 11 then\n          dashExaust = true\n          break\n        end\n      end\n      if repCount > 1 then\n        -- Found direction repetition. Calculate dash path.\n        local exits = getRoomExits(mmp.speedWalkPath[index + (repCount - 1)])\n        local pname = \"\"\n        for word in mmp.speedWalkDir[index]:gmatch(\"%w\") do\n          pname = pname .. (dRef[word] or word)\n        end\n        if not exits[pname] or dashExaust then\n          -- Final room in this direction does not continue, dash!\n          table.insert(currentPath, string.format(\"%s %s\", dashtype, mmp.speedWalkDir[index]))\n          currentIds[#currentIds + 1] = mmp.speedWalkPath[index + repCount - 1]\n        else\n          -- Final room in this direction continues onwards, don't dash unless on achaea\n          if mmp.game == \"achaea\" then\n            table.insert(\n              currentPath, string.format(\"%s %s %s\", dashtype, mmp.speedWalkDir[index], repCount)\n            )\n            currentIds[#currentIds + 1] = mmp.speedWalkPath[index + repCount - 1]\n          else\n            for i = 1, repCount do\n              table.insert(currentPath, mmp.speedWalkDir[index])\n              currentIds[#currentIds + 1] = mmp.speedWalkPath[index + i - 1]\n            end\n          end\n        end\n        index = index + repCount\n      else\n        -- No repetition, just add the direction.\n        table.insert(currentPath, mmp.speedWalkDir[index])\n        currentIds[#currentIds + 1] = mmp.speedWalkPath[index]\n        index = index + 1\n      end\n    else\n      -- Special exit, skip over this step\n      table.insert(currentPath, mmp.speedWalkDir[index])\n      currentIds[#currentIds + 1] = mmp.speedWalkPath[index]\n      index = index + 1\n    end\n  end\n  mmp.speedWalkDir = currentPath\n  mmp.speedWalkPath = currentIds\n  return true\nend\n\n-- a certain version of the mapper gave us special exits prepended with 0 or 1 in the command\n-- depending on if it was locked. Need to remove these before we can use them\n\nfunction mmp.fixSpecialExits(directions)\n  for i = 1, #directions do\n    if directions[i]:match(\"^%d\") then\n      directions[i] = directions[i]:sub(2)\n    end\n  end\nend\n\n-- cleanup function to remove the temp special exit we made\n\nfunction mmp.clearspecials(deleterooms)\n  local t = getSpecialExits(mmp.currentroom)\n  for connectingroom, exits in pairs(t) do\n    if table.contains(deleterooms, connectingroom) then\n      -- delete the special exits linking to this room\n      for command, locked in pairs(exits) do\n        removeSpecialExit(mmp.currentroom, command)\n      end\n    end\n  end\nend\n\nfunction mmp.getShortestOfMultipleRooms(possibleRooms)\n  local shortestWeight, closestRoom = 10000000, 0\n  local checkedsofar, outoftime = 0, false\n  local getStopWatchTime, tonumber = getStopWatchTime, tonumber\n\n  -- allocate only 500ms to finding the shortest path, or more if we failed to find anything\n  mmp.computeShortestWatch = mmp.computeShortestWatch or createStopWatch()\n  startStopWatch(mmp.computeShortestWatch)\n  raiseEvent(\"mmp link externals\")\n\n  -- mmp.echo(string.format(\"Have %s rooms nodes, %ss taken so far...\", table.size(possibleRooms), getStopWatchTime(mmp.computeShortestWatch)))\n  for _, id in pairs(possibleRooms) do\n    local possible, thisWeight = getPath(mmp.currentroom, tonumber(id))\n    if possible and thisWeight < shortestWeight then\n      shortestWeight = thisWeight\n      closestRoom = tonumber(id)\n    end\n    checkedsofar = checkedsofar + 1\n    if (getStopWatchTime(mmp.computeShortestWatch) >= .5) then\n      outoftime = true\n      break\n    end\n\n    -- mmp.echo(string.format(\"pathed from %s to %s, running time so far: %s\", mmp.currentroom, id, getStopWatchTime(mmp.computeShortestWatch)))\n  end\n  --mmp.echo(string.format(\"total time took: %s\", getStopWatchTime(mmp.computeShortestWatch)))\n  stopStopWatch(mmp.computeShortestWatch)\n  return closestRoom, outoftime, checkedsofar\nend\n\nfunction mmp.gotoAreaID(areaid, number, dashtype)\n  if not areaid or not tonumber(areaid) then\n    mmp.echo(\"To where do you want to go?\")\n    return\n  end\n  areaid = tonumber(areaid)\n  if not mmp.areatabler[areaid] then\n    mmp.echo(\"Invalid area ID selected\")\n    return\n  end\n  local possibleRooms, shortestBorder = {}, 0\n  for id,_ in pairs(mmp.getAreaBorders(areaid)) do\n    possibleRooms[#possibleRooms+1] = id\n  end\n  shortestBorder, outoftime, checkedsofar = mmp.getShortestOfMultipleRooms(possibleRooms)\n  if shortestBorder == 0 then\n    if outoftime then\n      mmp.echo(\n        string.format(\n          \"I checked %d of the %d possible exits \\\"%s\\\" has, but none of the ways there worked and it was taking too long :( try doing this again?\",\n          checkedsofar,\n          table.size(possibleRooms),\n          getRoomAreaName(areaid)\n        )\n      )\n    else\n      mmp.echo(\n        \"Checked \" ..\n        table.size(possibleRooms) ..\n        \" exits in that area, and none of them worked :( I Don't know how to get you there.\"\n      )\n    end\n    mmp.speedWalkPath = {}\n    mmp.speedWalkDir = {}\n    speedWalkCounter = 0\n    raiseEvent(\"mmapper failed path\")\n    raiseEvent(\"mmp clear externals\")\n    return\n  end\n  raiseEvent(\"mmp clear externals\")\n  mmp.gotoRoom(shortestBorder, dashtype, \"area\")\nend\n\nfunction mmp.gotoFeature(partialFeatureName, dashtype)\n  local mapFeatures = mmp.getMapFeatures()\n  local feature\n  if mapFeatures[partialFeatureName:lower()] then\n    feature = partialFeatureName:lower()\n  else\n    for key in pairs(mapFeatures) do\n      if key:find(partialFeatureName:lower()) then\n        feature = key\n        break\n      end\n    end\n  end\n  if not feature then\n    mmp.echo(\"No feature like \" .. partialFeatureName .. \" found.\")\n    return\n  end\n  local possibleRooms = searchRoomUserData(\"feature-\" .. feature, \"true\")\n  closestFeature, outoftime, checkedsofar = mmp.getShortestOfMultipleRooms(possibleRooms)\n  if closestFeature == 0 then\n    if outoftime then\n      mmp.echo(\n        string.format(\n          \"I checked %d of the %d possible features \\\"%s\\\" has, but none of the ways there worked and it was taking too long :( try doing this again?\",\n          checkedsofar,\n          table.size(possibleRooms),\n          partialFeatureName\n        )\n      )\n    else\n      mmp.echo(\n        \"Checked \" ..\n        table.size(possibleRooms) ..\n        \" rooms with that feature, and none of them worked :( I Don't know how to get you there.\"\n      )\n    end\n    mmp.speedWalkPath = {}\n    mmp.speedWalkDir = {}\n    speedWalkCounter = 0\n    raiseEvent(\"mmapper failed path\")\n    raiseEvent(\"mmp clear externals\")\n    return\n  end\n  raiseEvent(\"mmp clear externals\")\n  mmp.gotoRoom(closestFeature, dashtype, \"area\")\nend",
    "eventHandlerList": "\n\t\t\t\t\t\t"
}