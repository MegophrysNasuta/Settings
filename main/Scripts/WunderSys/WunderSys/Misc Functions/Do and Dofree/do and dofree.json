{
    "attribs": {
        "isActive": "yes",
        "isFolder": "no"
    },
    "type": "script",
    "name": "do and dofree",
    "packageName": null,
    "script": "wsys.dofreequeue = wsys.dofreequeue or {}\nwsys.dofreeSub = wsys.dofreeSub or {}\nwsys.doqueue = wsys.doqueue or {}\nwsys.doOnce_list = wsys.doOnce_list or {}\n\nwsys.doSub = wsys.doSub or \"\"\nwsys.dorSub = wsys.dorSub or \"\"\n\nwsys.doqueued = false\n\nlocal function expand_command( str )\n  str = str:gsub( \"^ONCE: \", \"\")\n  return str:gsub( \"$(%w+)\", \n    function( n )\n\t\t  local expand_to = wsys.overrides.doqueue.expand[ n ]\n      return expand_to and expand_to() or n\n\t\tend)\nend\n\nlocal function eval_command( element )\n  if element.label and wsys.doOnce_list[element.label] then\n    return wsys.doOnce_list[element.label]()\n  else\n\t  return expand_command( element.ac )\n  end\nend\n\n--use / to seperate multiple commands\n--ex. wsys.dofreeadd(\"g gold/put gold in \"..myPack)\nfunction wsys.dofreeadd(ac, silent)\n  local dofreequeuesize = #wsys.dofreequeue\n  if dofreequeuesize < 7 then\n      send(\"setalias dofree\"..tostring(dofreequeuesize+1)..\" \"..ac, not silent)\n      send(\"queue add \" .. wsys.selectDofreeQueue() .. \" dofree\"..tostring(dofreequeuesize+1), not silent)\n      wsys.dofreequeue[dofreequeuesize+1] = ac\n  else\n    cecho(\"\\n<red>DOFREE QUEUE FULL! Couldn't add \"..ac)\n  end\nend\n\nfunction wsys.dofreefirst(ac, silent)\n  local dofreequeuesize = #wsys.dofreequeue\n  if dofreequeuesize < 7 then\n      send(\"setalias dofree\"..tostring(dofreequeuesize+1)..\" \"..ac, not silent)\n      send(\"queue prepend \" .. wsys.selectDofreeQueue() .. \" dofree\"..tostring(dofreequeuesize+1), not silent)\n      wsys.dofreequeue[dofreequeuesize+1] = ac\n  else\n    cecho(\"\\n<red>DOFREE QUEUE FULL! Couldn't add \"..ac)\n  end\nend\n\nfunction wsys.selectDofreeQueue()\n  if wsys.bals.b and wsys.bals.e then\n    return \"bal\"\n  elseif wsys.bals.b and not wsys.bals.e then\n    return \"eq\"\n  elseif not wsys.bals.b and wsys.bals.e then\n    return \"bal\"\n  elseif not wsys.bals.b and not wsys.bals.e then\n    return \"bal\"\n  end\nend\n\nfunction wsys.dofreeremove(n)\n  wsys.dofreequeue[tonumber(n)] = nil\nend\n\nfunction wsys.dofreeclear()\n  wsys.dofreequeue = {}\nend\n\n--queue[i] = { element = \"action\", priority = [1-N] } --1 is highest priority\nlocal default_queue_priority = 25 --arbitrary low priority. Picked this because curing/defences use 1-25\nfunction wsys.priority_queue_insert( queue, element, priority, lifo )\n  local inserted = false\n  for index,item in ipairs(queue) do\n    if priority < item.priority then\n      -- New priority is lower than existing. Insert\n      table.insert( queue, index, { element = element, priority = priority } )\n      inserted = true\n      break\n    elseif priority == item.priority then\n      --Same priority. If lifo, insert, else go until lower\n      if lifo then\n        table.insert( queue, index, { element = element, priority = priority } )\n        inserted = true\n        break\n      end\n    end\n  end\n  if not inserted then\n    -- Add to the end\n    table.insert( queue, { element = element, priority = priority } )\n  end\nend\n\nfunction wsys.doadd(ac, priority, silent, on_run )\n  wsys.priority_queue_insert( wsys.doqueue, { ac = ac, silent = silent, on_run = on_run }, priority or default_queue_priority )\n  \n\t-- TODO: Need to check for priority?\n\tif not wsys.doqueue_pending then\n\t\twsys.dosend()\n  end\nend\n \nfunction wsys.dofirst(ac, priority, silent, on_run )\n  wsys.priority_queue_insert( wsys.doqueue, { ac = ac, silent = silent, on_run = on_run }, priority or default_queue_priority, true )\n  wsys.dosend()\nend\n\nfunction wsys.doOnce( label, priority, silent )\n  local match_found = false\n  --Check the current pending command for a match\n  if wsys.doqueue_pending and wsys.doqueue_pending.element.label and wsys.doqueue_pending.element.label == label then\n    --Match found. See if we need to update\n    wsys.doupdate()\n    match_found = true\n  else\n    for i,item in ipairs( wsys.doqueue ) do\n      if item.element.label == label then\n        match_found = true\n        --TODO: Update priority?\n        break\n      end\n    end\n  end\n\n  if not match_found then\n    wsys.priority_queue_insert( wsys.doqueue, { ac = \"ONCE: \"..label, silent = silent, label = label }, priority or default_queue_priority, true )\n    wsys.dosend()\n  end\nend\n\nfunction wsys.doupdate()\n\t--Check this from aff tracking update?\n  if wsys.doqueue_pending then\n    local text = eval_command( wsys.doqueue_pending.element )\n    if not text or #text == 0 then\n      wsys.debug(\"\\ndoupdate() Updating action! Is now empty\")\n      --Action is empty. Remove it and queue the next thing\n      send(\"clearqueue eqbal\", false )\n      -- Make sure the next command gets sent\n      wsys.dosent()\n    elseif wsys.do1_eval ~= text then\n      wsys.debug(\"\\ndoupdate() Updating attack!\")\n      wsys.do1_eval = text\n      send(\"setalias do1 \"..wsys.do1_eval, not wsys.doqueue_pending.element.silent )\n    end\n  end\nend\n\nlocal function get_next_action()\n  while #wsys.doqueue > 0 do\n    local text = eval_command( wsys.doqueue[1].element )\n    if text and #text > 0 then\n      return text\n    else\n      -- action evaluated to nil or empty string. Remove it\n      table.remove(wsys.doqueue, 1)\n    end\n  end\n  return false\nend\n\nfunction wsys.dosend()\n  wsys.debug( \"dosend() - dowait = \" .. ( tostring(wsys.timer.dowait) or \"nil\" ) )\n  wsys.debug(\"\\ndosend() - \" .. #wsys.doqueue .. \" queued.\")\n  if not wsys.paused then--or\tnot wsys.timer.dowait then\n  local text = get_next_action()\n    if text then\n\t\tif wsys.doqueued and wsys.doqueue_pending and ( wsys.do1_eval == text or wsys.doqueue_pending.priority < wsys.doqueue[1].priority ) then\n\t\t\t--Next element is same as pending command, or higher priority. Don't re-queue\n\t\t\twsys.debug(\"\\ndosend() returning early \"..wsys.do1_eval)\n\t\t\treturn\n\t\tend\n      wsys.timer.dowait = tempTimer(wsys.myPing()*3, [[wsys.timer.dowait = nil]])\n\t\twsys.do1_eval = text\n      send(\"setalias do1 \"..wsys.do1_eval , not wsys.doqueue[1].element.silent )\n      --if wsys.doraction then\n        send(\"clearqueue eqbal\", not wsys.doqueue[1].element.silent )\n      --end\n      wsys.doqueued = true\n      send(\"queue add eqbal do1\", not wsys.doqueue[1].element.silent )\n      local temp = wsys.doqueue[1]\n      if wsys.doqueue_pending then\n        --We interrupted a pending command. Add back to the list\n        wsys.doqueue[1] = wsys.doqueue_pending\n      else\n        table.remove(wsys.doqueue, 1)\n      end\n      wsys.doqueue_pending = temp\n    elseif wsys.doraction and not wsys.uselyre then\n      wsys.timer.dowait = tempTimer(wsys.myPing()*1.5, [[wsys.timer.dowait = nil]])\n      send(\"queue add eqbal dor\")\n      if wsys.timer.dorfailsafe then killTimer(wsys.timer.dorfailsafe) end\n      wsys.timer.dorfailsafe = tempTimer(3.5, [[wsys.timer.dorfailsafe = nil;if wsys.bals.b and wsys.bals.e then wsys.dosend() end]])\n    end\n  end\nend\n\nfunction wsys.dosent(type)\n  if type == \"do\" then\n    raiseEvent(\"do action ran\", wsys.doSub)\n\t\t\n\t\tif wsys.doqueue_pending and wsys.doqueue_pending.element.on_run then\n\t\t\twsys.doqueue_pending.element.on_run()\n\t\tend\n\t\t\n  elseif type == \"dor\" then\n    raiseEvent(\"dor action ran\", wsys.dorSub)\n  end\n\t\n  wsys.doqueued = false\n  wsys.doqueue_pending = nil\n  if wsys.timer.dowait then\n    killTimer(wsys.timer.dowait)\n    wsys.timer.dowait = nil\n  end\n  if wsys.timer.dorfailsafe then\n    killTimer(wsys.timer.dorfailsafe)\n    wsys.timer.dorfailsafe = nil\n  end\n  wsys.dosend()\nend\n\nfunction wsys.dolist()\n        --NOTE: Feel free to pretty this up\n        local color = \"<white>\"\n        cecho(color..\"[Do]: List -\\n\")\n        if wsys.doqueue_pending then\n                cecho(color..\"0: (\"..wsys.doqueue_pending.priority..\") \"..wsys.doqueue_pending.element.ac..\"\\n\")\n        end\n        for i,v in pairs( wsys.doqueue ) do\n                cecho(color..i..\": (\"..v.priority..\") \"..v.element.ac..\"\\n\")\n        end\nend\n\n\n-- remove the first element (either lifo or fifo) from the queue with priority [low, high] (inclusive)\nfunction wsys.undo( lifo, low, high, all )\n        local index = lifo and 0 or #wsys.doqueue --index to start with\n        low = low or 25\n \n        local valid_index = function(i) return ( i and i >= 0 and i <= #wsys.doqueue ) and i or false end\n        local next_index = function(i) return lifo and valid_index(i+1) or valid_index(i-1) end\n        local should_remove = function(t) return t.priority >= low and ( not high or t.priority <= high ) end\n        local echo_removed = function(t) cecho(\"<white>[Do]: Removed (\"..t.priority..\") '\"..t.element.ac..\"' from the do queue.\\n\") end\n       \n        while valid_index(index) do\n                if index == 0 then\n                        --Index 0 indicates a command we already queued. Only try to remove it if we don't have bal and eq\n                        if wsys.doqueue_pending and not (wsys.bals.b and wsys.bals.e ) and should_remove( wsys.doqueue_pending ) then\n                                echo_removed( wsys.doqueue_pending )\n                                send(\"clearqueue eqbal\", false)\n                                wsys.doqueue_pending = nil\n                                if not all then\n                                        --Make sure the next command gets queued\n                                        wsys.dosent(\"do\")\n                                        return true\n                                end\n                        else\n                                index = next_index( index )\n                        end\n                elseif wsys.doqueue[index] and should_remove( wsys.doqueue[index] ) then\n                        echo_removed( wsys.doqueue[index] )\n                        table.remove( wsys.doqueue, index )\n                        if not all then\n                                return true\n                        elseif not lifo then\n                                index = index - 1\n                        end\n                else\n                        index = next_index( index )\n                end\n        end\n        if #wsys.doqueue == 0 then\n                cecho(\"<white>[Do]: The do queue is empty.\\n\")\n        end\n        return false\nend\n\nfunction wsys.undoall( lifo, low, high )\n\twsys.undo( lifo, low, high, true )\nend\n\n--registerAnonymousEventHandler(\"lost balance\", \"wsys.dosent\")\n--registerAnonymousEventHandler(\"lost equilibrium\", \"wsys.dosent\")\n\nfunction wsys.dofailsafes()\n  wsys.doqueued = false\n  wsys.dofreeclear()\nend\n\nregisterAnonymousEventHandler(\"got balance\", \"wsys.dofailsafes\")\nregisterAnonymousEventHandler(\"got equilibrium\", \"wsys.dofailsafes\")\n\n--dor\nfunction wsys.doradd(a)\n  wsys.doraction = a\n  send(\"setalias dor \"..wsys.doraction, false)\n  wsys.dosend()\nend\n\n\nfunction wsys.dorclear()\n  wsys.doraction = false\n  send(\"clearqueue eqbal\", false)\n  wsys.report(\"<green>Cleared the dorepeat queue.\")\nend",
    "eventHandlerList": null
}